### 守护线程与用户线程

**守护线程**（Daemon Thread）：专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。

**用户线程**（User Thread）：应用程序里的线程，一般都是用户自定义线程。用户也可以在应用程序代码自定义守护线程，只需要调用Thread类的设置方法（setDaemon()）设置一下即可。

**注意**：

(1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
(2) 在Daemon线程中产生的新线程也是Daemon的。 
(3) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。  

### 创建线程的三种方式

- 通过实现Runnable接口实现

```

```

- 通过继承Thread类实现

```

```

- 通过Callable和Future实现

```

```

### 线程的状态

线程总共包括5种状态：

- **新建状态**：使用 **new** 关键字和 **Thread** 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 **start()** 这个线程。
- **就绪状态**：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- **运行状态**：如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
- **阻塞状态**：可分为三种：
  - **等待阻塞**：运行状态中的线程执行wait()方法，便进入等待阻塞状态
  - **同步阻塞**：线程在获取synchronized同步锁失败（因同步锁被其他线程所占用）
  - **其他阻塞**：通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

- **死亡状态**：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 线程池

what：容纳多线程的容器，其中的线程可多次反复使用。

why：尽可能减少创建或销毁线程的次数，减少系统资源消耗。

### 线程同步

synchronized()

wait()：导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在**同步方法**中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。释放锁，并被挂起。

notify()：

notifyAll()：